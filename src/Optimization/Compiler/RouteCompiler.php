<?php

namespace Ludelix\Optimization\Compiler;

/**
 * Route Compiler Optimizer
 * 
 * Compiles and optimizes routes for production
 */
class RouteCompiler
{
    protected array $config;
    protected array $compiledRoutes = [];

    public function __construct(array $config = [])
    {
        $this->config = array_merge([
            'cache_path' => 'cubby/cache/routes.php',
            'optimize_patterns' => true,
            'group_by_method' => true
        ], $config);
    }

    /**
     * Compile routes from configuration
     */
    public function compile(array $routes): string
    {
        $optimized = $this->optimize($routes);
        $compiled = $this->generateCompiledRoutes($optimized);
        
        $this->ensureDirectory(dirname($this->config['cache_path']));
        file_put_contents($this->config['cache_path'], $compiled);
        
        return $this->config['cache_path'];
    }

    /**
     * Optimize routes
     */
    protected function optimize(array $routes): array
    {
        $optimized = [];

        foreach ($routes as $route) {
            $optimizedRoute = $this->optimizeRoute($route);
            $optimized[] = $optimizedRoute;
        }

        // Group by method if enabled
        if ($this->config['group_by_method']) {
            $optimized = $this->groupByMethod($optimized);
        }

        return $optimized;
    }

    /**
     * Optimize single route
     */
    protected function optimizeRoute(array $route): array
    {
        // Compile regex patterns
        if ($this->config['optimize_patterns']) {
            $route['compiled_pattern'] = $this->compilePattern($route['path']);
        }

        // Pre-resolve middleware
        if (isset($route['middleware'])) {
            $route['resolved_middleware'] = $this->resolveMiddleware($route['middleware']);
        }

        return $route;
    }

    /**
     * Compile route pattern to regex
     */
    protected function compilePattern(string $pattern): string
    {
        // Convert route parameters to regex
        $pattern = preg_replace('/\{(\w+)\}/', '(?P<$1>[^/]+)', $pattern);
        $pattern = preg_replace('/\{(\w+)\?\}/', '(?P<$1>[^/]*)', $pattern);
        
        return '#^' . $pattern . '$#';
    }

    /**
     * Resolve middleware classes
     */
    protected function resolveMiddleware(array $middleware): array
    {
        $resolved = [];
        
        foreach ($middleware as $mw) {
            if (is_string($mw)) {
                $resolved[] = $this->resolveMiddlewareClass($mw);
            } else {
                $resolved[] = $mw;
            }
        }
        
        return $resolved;
    }

    /**
     * Resolve middleware class name
     */
    protected function resolveMiddlewareClass(string $middleware): string
    {
        $middlewareMap = [
            'auth' => 'Ludelix\\Routing\\Middleware\\Authenticate',
            'api' => 'Ludelix\\Routing\\Middleware\\ApiVersionMiddleware',
            'rate_limit' => 'Ludelix\\Routing\\Middleware\\RateLimitMiddleware'
        ];

        return $middlewareMap[$middleware] ?? $middleware;
    }

    /**
     * Group routes by HTTP method
     */
    protected function groupByMethod(array $routes): array
    {
        $grouped = [];

        foreach ($routes as $route) {
            $methods = is_array($route['method']) ? $route['method'] : [$route['method']];
            
            foreach ($methods as $method) {
                if (!isset($grouped[$method])) {
                    $grouped[$method] = [];
                }
                $grouped[$method][] = $route;
            }
        }

        return $grouped;
    }

    /**
     * Generate compiled routes PHP code
     */
    protected function generateCompiledRoutes(array $routes): string
    {
        $code = "<?php\n\n";
        $code .= "// Compiled routes - Generated on " . date('Y-m-d H:i:s') . "\n";
        $code .= "// Do not edit this file manually\n\n";
        $code .= "return " . var_export($routes, true) . ";\n";

        return $code;
    }

    /**
     * Load compiled routes
     */
    public function loadCompiled(): ?array
    {
        if (!file_exists($this->config['cache_path'])) {
            return null;
        }

        return include $this->config['cache_path'];
    }

    /**
     * Check if routes need recompilation
     */
    public function needsRecompilation(array $sourceFiles): bool
    {
        if (!file_exists($this->config['cache_path'])) {
            return true;
        }

        $cacheTime = filemtime($this->config['cache_path']);

        foreach ($sourceFiles as $file) {
            if (file_exists($file) && filemtime($file) > $cacheTime) {
                return true;
            }
        }

        return false;
    }

    /**
     * Clear compiled routes
     */
    public function clear(): void
    {
        if (file_exists($this->config['cache_path'])) {
            unlink($this->config['cache_path']);
        }
    }

    /**
     * Ensure directory exists
     */
    protected function ensureDirectory(string $path): void
    {
        if (!is_dir($path)) {
            mkdir($path, 0755, true);
        }
    }

    /**
     * Get compilation stats
     */
    public function getStats(): array
    {
        return [
            'cache_file' => $this->config['cache_path'],
            'exists' => file_exists($this->config['cache_path']),
            'size' => file_exists($this->config['cache_path']) ? filesize($this->config['cache_path']) : 0,
            'modified' => file_exists($this->config['cache_path']) ? date('Y-m-d H:i:s', filemtime($this->config['cache_path'])) : null
        ];
    }
}